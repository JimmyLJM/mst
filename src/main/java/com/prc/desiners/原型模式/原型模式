
## 定义与特点
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。

## 结构与实现
由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单

- 抽象原型类：规定了具体原型对象必须实现的接口。
- 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
- 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

浅克隆和深克隆

- 浅克隆:
浅度克隆，当被克隆的类中有引用对象（String或Integer等包装类型除外）时，
克隆出来的类中的引用变量存储的还是之前的内存地址，也就是说克隆与被克隆的对象是同一个。
这样的话两个对象共享了一个私有变量，所有人都可以改，是一个种非常不安全的方式，在实际项目中使用还是比较少的。

- 深克隆
    - 对象的类实现Cloneable接口；
    - 覆盖Object类的clone()方法 （覆盖clone()方法，访问修饰符设为public，默认是protected）；
    - 在clone()方法中调用super.clone()；
## 应用场景 
- 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
- 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
- 隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。
- 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；
- 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式先产生出一个包含

大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。

```
TIP：对象拷贝时，类的构造函数是不会被执行的。一个实现了 Cloneable 并重写了 clone 方法的类 A,
有一个无参构造或有参构造 B，通过 new 关键字产生了一个对象 S，
再然后通过 S.clone()方式产生了一个新的对象 T，
那么在对象拷贝时构造函数 B 是不会被执行的， 对象拷贝时确实构造函数没有被执行，
这个从原理来讲也是可以讲得通的，Object 类的 clone 方法的 
原理是从内存中（具体的说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数 没有被执行也是非常正常的了。
```

##




