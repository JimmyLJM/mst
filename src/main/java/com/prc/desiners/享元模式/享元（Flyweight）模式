## 定义
运用共享技术来有効地支持大量细粒度对象的复用。
它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率

## 结构
享元模式中存在以下两种状态：
- 内部状态，即不会随着环境的改变而改变的可共享部分；
- 外部状态，指随环境改变而改变的不可以共享的部分。
享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。

角色：
- 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
- 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
- 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
- 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，
享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。



## 优点&缺点

- 优点
    - 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
    - 节约系统的开销。保证一个常用的对象只有一个！
    - 外部状态不会影响内部状态，可以在不同环境下进行共享哦。
- 缺点
    - 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
    - 读取享元模式的外部状态会使得运行时间稍微变长。
    - 享元模式使逻辑变得更加复杂，需要将享元对象分出内部状态和外部状态。
    - 并且为了使对象可以共享，外部状态在很多情况下是必须有的，比如围棋的位置。当读取外部状态时明显会增加运行时间。


## 应用场景
- 一个系统有大量细粒度化的对象，占据大量的内存。
- 对象大部分属性可以外部化，并且能将外部的属性放入内部属性中来。
- 使用享元模式需要维护享元池，所以要用那种常用的经常调用的对象可以使用享元模式。



























